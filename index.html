<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Hpmc by cdyk</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/cdyk/hpmc">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/cdyk/hpmc/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/cdyk/hpmc/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Hpmc</h1>
          <p>HPMC is a small OpenGL/C/C++-library that extractes iso-surfaces of volumetric data directly on the GPU.</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/cdyk">cdyk</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></span>
        </div>

        <h3>Overview</h3>

<p>HPMC is an implementation of the method described in the paper</p>

<blockquote>
<p>C. Dyken, G. Ziegler, C. Theobalt, H.-P. Seidel,
<a href="http://heim.ifi.uio.no/%7Eerikd/pdf/hpmarcher_draft.pdf">High-speed Marching Cubes using Histogram Pyramids</a>,
Computer Graphics Forum 27 (8), 2008.</p>
</blockquote>

<p>The library analyzes a lattice of scalar values describing a scalar field that is either stored in a Texture3D or can be accessed through an application-provided snippet of shader code. The output is a sequence of vertex positions and normals that form a triangulation of the iso-surface. HPMC provides traversal code to be included in an application vertex shader, which allows direct extraction in the vertex shader. Using the OpenGL transform feedback mechanism, the triangulation can be stored directly into a buffer object.  </p>

<h5>License</h5>

<p>HPMC is released under GNU General Public License ("GPL") version 2 as published by the Free Software Foundation. For use of HPMC with software than can not be combined with the GNU GPL 2, please contact <a href="http://www.sintef.no/heterocomp">SINTEF</a> for aquiring a commercial license and support.</p>

<h5>News</h5>

<ul>
<li>[2012-09-24] Tested against OpenGL 4.3, no issues found with compatability mode. Full compliance for core profiles will be included in the next release.</li>
<li>[2009-12-01] Version 1.0.1 released, fixes some Mac-specific issues.</li>
<li>[2009-11-29] Version 1.0 released, first public release.</li>
</ul><h5>Roadmap</h5>

<ul>
<li>Full compliance with core profiles.</li>
<li>API entry point for use with XBOs.</li>
<li>Use indirect rendering (removing the single sync currently needed).</li>
<li>Direct support for scalar field lattice in a tiled Texture2D (aka Flat3D).</li>
<li>Fetch from packed Texture3D. Here, four z-slices are packed in the RGBA-channels; this is useful when building the 3D texture on GPU quartering the number of rendering passes.</li>
<li>Your suggestions.</li>
</ul><h5>Helping out</h5>

<p>The best way of helping out is to use HPMC. Bug reports and patches are always welcome; If you have trouble with HPMC on a system configuration that should be able to run it, please contact the author. Also, if you find this software useful, sending the author an email stating this is an excellent motivation for continuing the development.</p>

<h3>Releases</h3>

<ul>
<li>Version 1.0.1 (current release)
<ul>
<li>
<a href="http://erikd.at.ifi.uio.no/hpmc-1.0.1.tar.gz">hpmc-1.0.1.tar.gz</a> Full source code.</li>
<li>
<a href="http://erikd.at.ifi.uio.no/hpmc-1.0.1.zip">hpmc-1.0.1.zip</a> Full source code with Visual Studio 2008 
solution and project files.</li>
<li><a href="http://public.ict.sintef.no/hpmc/doxydocs/index.html">Online documentation</a>.</li>
<li>Minimal system requirements
<ul>
<li>CMake, unless you use the Visual Studio solution.</li>
<li>GLEW 1.5.1 or newer.</li>
<li>FreeGLUT or GLUT if you intend to build the sample applications.</li>
<li>OpenGL 2.0 with GL_ARB_texture_float extension allowing texturing from mip-map'ed GL_ALPHA32F_ARB Texture2D in the vertex shader.</li>
<li>OpenGL 2.0 with support of texturing from Texture3D in the vertex shader is required if you intend to encode the scalar field in a 3D texture.</li>
<li>OpenGL 3.0 or OpenGL 2.0 with either GL_NV_transform_feedback or GL_EXT_transform_feedback if you intend to use transform feedback.</li>
</ul>
</li>
<li>Built and tested on the following configurations:
<ul>
<li>Gentoo linux-2.6.30, GeForce GTX 260, NVIDIA Display Driver 190.18.05.</li>
<li>Gentoo linux-2.6.30, GeForce 8400M GS,NVIDA Display Driver 190.42</li>
<li>Gentoo linux-2.6.30, FireStream 9250, ATI Catalyst 9.10,<br>
</li>
<li>Gentoo linux-2.6.30, GeForce 6600 GT, NVIDA Display Driver 190.42. <em>Note: Transform_feedback and particles not running, as transform_feedback is not supported by card. Texturing from Texture3D is slow, proably due to lack of hardware support. G80 emulation (Cheetah renderer string) does not work</em>.</li>
<li>Gentoo linux-2.6.31 AMD64, GTX 260, NVIDIA Display Driver 195.17</li>
<li>Ubuntu 9.10 linux-2.6.31-15 x86_64, GeForce GTX 275, NVIDIA Display Driver 185.18.36. </li>
<li>Ubuntu 8.04.3 LTS, linux-2.6.25-25-generic x86_64, GeForce 8600 GT, NVIDIA Display Driver 173.14.12. <em>Note: Old GLEW 1.5.0</em>.</li>
<li>Windows 7 x64, Radeon HD 4870 X2, AMD Catalyst 9.11, 32-bit build.
<em>Note: particles do not run as only the pipeline for GL_NV_transform_feedback is implemented in the sample</em>.</li>
<li>Windows Vista, GeForce 8400M GS, NVIDIA Display Driver 190.38, MSVC9</li>
<li>Windows Vista, GeForce 260 GTX, NVIDIA Display Driver 185.85, MSVC9</li>
<li>Windows XP SP2, FireStream 9250, AMD Catalyst 9.11, MSVC8 2005 <em>Note: particles do not run as only the pipeline for GL_NV_transform_feedback is implemented in the sample</em>.</li>
<li>Windows XP SP2, GeForce 8800 GT, NVIDIA Display Driver 195.62, Visual Studio 2005.</li>
<li>MacOS X 10.6.2, GeForce 9400M, Display Driver 1.6.6, i686-apple-darwin10-gcc-4.2.1
<em>Note: particles do not run as GL_NV_transform_feedback seems to be missing</em>.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Sample applications</h3>

<p>The HPMC distribution currently contains five sample applications:</p>

<h4>Extracting iso-surfaces from an existing voxel set (texture3D.cpp)</h4>
<iframe align=right width="320" height="197" src="http://www.youtube.com/embed/Gl_ft7dxpps" frameborder="0" allowfullscreen></iframe>

<p>This example demonstrates the most basic use of HPMC, providing the scalar field as a 3D texture. The example gets volume dimensions and a file name of a 8-bit raw dataset from the command line, reads the data into a 3D texture and passes this texture to HPMC. For each frame, a time-dependent iso-value is calculated, passed to HPMC which analyzes the scalar field using this iso-value. Then, HPMC renders the corresponding iso-surface. Wireframe rendering is done straight-forwardly by rendering the surface twice (traversing the HistoPyramid both times), one time with solid triangles in a dark color offset slightly away from the camera, and the second time using the line-drawing polygon mode to render the actual wireframe in white.</p>

<h4>Extracting iso-surfaces from a scalar field defined using shader code (cayley.cpp)</h4>
<iframe align=right width="320" height="197" src="http://www.youtube.com/embed/c-o9IMto1ic" frameborder="0" allowfullscreen></iframe>

<p>This example is similar to the texture3d example. The difference is that instead of fetching scalar values from a texture 3d, the scalar value is fetched from an application provided shader function, which in this example evaluates the algebraic surface defined by 1 - 16xyz -4x^2 - 4y^2 - 4z^2 = iso. The application also provides the gradient field for this function, which is used instead of forward differences to determine surface normals.</p>

<p>For each frame, a time-dependent iso-value is calculated, passed to HPMC which analyzes the scalar field using this iso-value. Then, HPMC renders the corresponding iso-surface. Wireframe rendering is done straight-forwardly by rendering the surface twice (traversing the HistoPyramid both times), one time with solid triangles in a dark color offset slightly away from the camera, and the second time using the line-drawing polygon mode to render the actual wireframe in white.</p>

<h4>Metaballs (metaballs.cpp)</h4>
<iframe align=right width="320" height="197" src="http://www.youtube.com/embed/HJSkNlxiYH0" frameborder="0" allowfullscreen></iframe>

<p>This example demonstrates the use of a custom fetch function and how the application can get hold of program names to update uniform variables. In principle, the fetch calculates the distance field defined by eight metaballs, whose position is provided through uniform variables. To make the example more interesting, the domain is twisted time-dependently along the z- and y-axes.</p>

<h4>Basic use of transform feedback (tranform_feedback.cpp)</h4>
<iframe align=right width="320" height="197" src="http://www.youtube.com/embed/RlYYnsIS-Rs" frameborder="0" allowfullscreen></iframe>

<p>Extracting iso-surfaces from a scalar field defined in terms shader code, and use transform feedback to capture geometry for wireframe rendering. This example is basically the same as cayley, the main difference is that instead of traversing the HistoPyramid twice when rendering wireframe, transform feedback is used to capture the geometry in the flat shading pass, and the result of this is rendered again using plain OpenGL to produce the line rendering.</p>

<p>The actual surface is an algebraic surface defined by 1 - 16xyz -4x^2 - 4y^2 - 4z^2 = iso. The application also provides the gradient field for this function, which is used instead of forward differences to determine surface normals.</p>

<h4>Morphing algebraic shapes that emits particles (particles.cpp)</h4>
<iframe align=right width="320" height="197" src="http://www.youtube.com/embed/S5NZxxDooCU" frameborder="0" allowfullscreen></iframe>

<p>This example demonstrates using the surface generated by HPMC as input to a geometry shader that emits particles randomly over the surface. The particles are pulled by gravity, and uses the scalar field passed to HPMC to determine when particles hit the surface, and in this case, they bounce. To test if a particle hits the surface is done by evaluating the sign of the scalar field at the position of the particle at the beginning of the timestep and at the end. This approach is a bit too simple for these shapes, as they usually have a great deal of regions with multiple zeros, and this leads to the artefact of particles falling through the surface at some places.</p>

<p>The following render loop is used:</p>

<ul>
<li>Use HPMC to determine the iso-surface of the current scalar field</li>
<li>Render the iso surface, but tap vertex position and normals into a transform feedback buffer.</li>
<li>Pass this buffer into a geometry shader that emits particles (points) at some of the triangles, output stored in another transform feedback buffer.</li>
<li>Pass the particles from the previous frame into a geometry shader that does a series of Euler-steps to integrate velocity and position, checking for collisions in-between. The output of this pass is concatenated at the end of the newly created particles using transform feedback.</

<h3>Further references</h3>

<p>HistoPyramids are used and discussed in the following papers:</p>

<blockquote>
<p>C. Dyken, M. Reimers, J. Seland,
<a href="http://heim.ifi.uio.no/%7Eerikd/pdf/topofix_draft.pdf">Semi-uniform Adaptive Patch Tessellation</a>,
Computer Graphics Forum, to appear.</p>

<p>C. Dyken, M. Reimers, J. Seland,
<a href="http://heim.ifi.uio.no/%7Eerikd/pdf/silhouetteGPUdraft.pdf">Real-Time GPU Silhouette Refinement using adaptively blended Bezier Patches</a>,
Computer Graphics Forum 27 (1), 2008, pp. 1-12.</p>

<p>I. Ihrke, G. Ziegler, A. Tevs, C. Theobalt, M. Magnor, H.-P. Seidel,
<a href="http://www.mpi-inf.mpg.de/resources/EikonalRendering/index.html">Eikonal Rendering: Efficient Light Transport in Refractive Objects</a>,
ACM Transactions on Graphics (Proc. ACM SIGGRAPH) 26 (3): 59-1 - 59-8, 2007</p>

<p>G. Ziegler, R. Dimitrov, C. Theobalt, H.-P. Seidel,
<a href="https://domino.mpi-sb.mpg.de/intranet/ag4/ag4publ.nsf/ListPublications?OpenAgent&amp;author=Gernot+AND+Ziegler">Real-time Quadtree Analysis using HistoPyramids</a>,
Real-Time Image Processing 2007, San Jose, USA, 2007, 1-11</p>

<p>G. Ziegler, A. Tevs, C. Theobalt, H.-P. Seidel,
<a href="http://www.mpi-inf.mpg.de/%7Egziegler/gpu_pointlist/paper17_gpu_pointclouds.pdf">On-the-fly Point Clouds through Histogram Pyramids</a>,
11th International Fall Workshop on Vision, Modeling and Visualization 2006 (VMV2006), Aachen, Germany, 2006, 137-144</p>
</blockquote>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
