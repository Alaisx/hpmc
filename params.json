{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Hpmc","tagline":"HPMC is a small OpenGL/C/C++-library that extractes iso-surfaces of volumetric data directly on the GPU.","body":"### Overview\r\nHPMC is an implementation of the method described in the paper\r\n\r\n> C. Dyken, G. Ziegler, C. Theobalt, H.-P. Seidel,\r\n> [High-speed Marching Cubes using Histogram Pyramids](http://heim.ifi.uio.no/~erikd/pdf/hpmarcher_draft.pdf),\r\n> Computer Graphics Forum 27 (8), 2008.\r\n\r\nThe library analyzes a lattice of scalar values describing a scalar field that is either stored in a Texture3D or can be accessed through an application-provided snippet of shader code. The output is a sequence of vertex positions and normals that form a triangulation of the iso-surface. HPMC provides traversal code to be included in an application vertex shader, which allows direct extraction in the vertex shader. Using the OpenGL transform feedback mechanism, the triangulation can be stored directly into a buffer object.  \r\n\r\n##### License\r\nHPMC is released under GNU General Public License (\"GPL\") version 2 as published by the Free Software Foundation. For use of HPMC with software than can not be combined with the GNU GPL 2, please contact [SINTEF](http://www.sintef.no/heterocomp) for aquiring a commercial license and support.\r\n\r\n##### News\r\n* [2012-09-24] Tested against OpenGL 4.3, no issues found with compatability mode. Full compliance for core profiles will be included in the next release.\r\n* [2009-12-01] Version 1.0.1 released, fixes some Mac-specific issues.\r\n* [2009-11-29] Version 1.0 released, first public release.\r\n\r\n##### Roadmap\r\n\r\n* Full compliance with core profiles.\r\n* API entry point for use with XBOs.\r\n* Use indirect rendering (removing the single sync currently needed).\r\n* Direct support for scalar field lattice in a tiled Texture2D (aka Flat3D).\r\n* Fetch from packed Texture3D. Here, four z-slices are packed in the RGBA-channels; this is useful when building the 3D texture on GPU quartering the number of rendering passes.\r\n* Your suggestions.\r\n\r\n##### Helping out\r\n\r\nThe best way of helping out is to use HPMC. Bug reports and patches are always welcome; If you have trouble with HPMC on a system configuration that should be able to run it, please contact the author. Also, if you find this software useful, sending the author an email stating this is an excellent motivation for continuing the development.\r\n\r\n### Downloads\r\n\r\n##### Version 1.0.1 (current release)\r\n* [hpmc-1.0.1.tar.gz](http://erikd.at.ifi.uio.no/hpmc-1.0.1.tar.gz) Full source code.\r\n* [hpmc-1.0.1.zip](http://erikd.at.ifi.uio.no/hpmc-1.0.1.zip) Full source code with Visual Studio 2008 \r\nsolution and project files.\r\n\r\n##### Minimal system requirements:\r\n* A C++ compiler.\r\n* CMake, unless you use the Visual Studio solution.\r\n* GLEW, version 1.5.1 or newer.\r\n* An OpenGL implementation:\r\n  * Minimum is OpenGL 2.0 with GL_ARB_texture_float extension allowing texturing from a mip-map'ed GL_ALPHA32F_ARB Texture2D in the vertex shader.\r\n  * Support of texturing from Texture3D in the vertex shader is required if you intend to encode the scalar field in a 3D texture.\r\n  * Use of transform feedback requires either OpenGL 3.0, the GL_NV_transform_feedback, or the GL_EXT_transform_feedback extensions.\r\n* FreeGLUT or GLUT if you intend to build the examples..\r\n\r\nIn particular, HPMC has been tested and verified to work the following system configurations:\r\n* Gentoo linux-2.6.30, GeForce GTX 260, NVIDIA Display Driver 190.18.05.\r\n* Gentoo linux-2.6.30, GeForce 8400M GS,NVIDA Display Driver 190.42\r\n* Gentoo linux-2.6.30, FireStream 9250, ATI Catalyst 9.10,  \r\n* Gentoo linux-2.6.30, GeForce 6600 GT, NVIDA Display Driver 190.42. _Note: Transform_feedback and particles not running, as transform_feedback is not supported by card. Texturing from Texture3D is slow, proably due to lack of hardware support. G80 emulation (Cheetah renderer string) does not work_.\r\n* Gentoo linux-2.6.31 AMD64, GTX 260, NVIDIA Display Driver 195.17\r\n* Ubuntu 9.10 linux-2.6.31-15 x86_64, GeForce GTX 275, NVIDIA Display Driver 185.18.36. \r\n* Ubuntu 8.04.3 LTS, linux-2.6.25-25-generic x86_64, GeForce 8600 GT, NVIDIA Display Driver 173.14.12. _Note: Old GLEW 1.5.0_.\r\n* Windows 7 x64, Radeon HD 4870 X2, AMD Catalyst 9.11, 32-bit build.\r\n_Note: particles do not run as only the pipeline for GL_NV_transform_feedback is implemented in the sample_.\r\n* Windows Vista, GeForce 8400M GS, NVIDIA Display Driver 190.38, MSVC9\r\n* Windows Vista, GeForce 260 GTX, NVIDIA Display Driver 185.85, MSVC9\r\n* Windows XP SP2, FireStream 9250, AMD Catalyst 9.11, MSVC8 2005 _Note: particles do not run as only the pipeline for GL_NV_transform_feedback is implemented in the sample_.\r\n* Windows XP SP2, GeForce 8800 GT, NVIDIA Display Driver 195.62, Visual Studio 2005.\r\n* MacOS X 10.6.2, GeForce 9400M, Display Driver 1.6.6, i686-apple-darwin10-gcc-4.2.1\r\n  _Note: particles do not run as GL_NV_transform_feedback seems to be missing_.\r\n\r\n### Sample applications\r\n\r\nThe HPMC distribution currently contains five sample applications:\r\n\r\n##### Extracting iso-surfaces from an existing voxel set (texture3D.cpp)\r\n\r\nThis example demonstrates the most basic use of HPMC, providing the scalar field as a 3D texture. The example gets volume dimensions and a file name of a 8-bit raw dataset from the command line, reads the data into a 3D texture and passes this texture to HPMC. For each frame, a time-dependent iso-value is calculated, passed to HPMC which analyzes the scalar field using this iso-value. Then, HPMC renders the corresponding iso-surface. Wireframe rendering is done straight-forwardly by rendering the surface twice (traversing the HistoPyramid both times), one time with solid triangles in a dark color offset slightly away from the camera, and the second time using the line-drawing polygon mode to render the actual wireframe in white.\r\n\r\n* [Video on Youtube](http://youtu.be/Gl_ft7dxpps).\r\n\r\n##### Extracting iso-surfaces from a scalar field defined using shader code (cayley.cpp)\r\n\r\nThis example is similar to the texture3d example. The difference is that instead of fetching scalar values from a texture 3d, the scalar value is fetched from an application provided shader function, which in this example evaluates the algebraic surface defined by 1 - 16xyz -4x^2 - 4y^2 - 4z^2 = iso. The application also provides the gradient field for this function, which is used instead of forward differences to determine surface normals.\r\n\r\nFor each frame, a time-dependent iso-value is calculated, passed to HPMC which analyzes the scalar field using this iso-value. Then, HPMC renders the corresponding iso-surface. Wireframe rendering is done straight-forwardly by rendering the surface twice (traversing the HistoPyramid both times), one time with solid triangles in a dark color offset slightly away from the camera, and the second time using the line-drawing polygon mode to render the actual wireframe in white.\r\n\r\n* [Video on YouTube](http://youtu.be/c-o9IMto1ic).\r\n\r\n##### Metaballs (metaballs.cpp)\r\n\r\nThis example demonstrates the use of a custom fetch function and how the application can get hold of program names to update uniform variables. In principle, the fetch calculates the distance field defined by eight metaballs, whose position is provided through uniform variables. To make the example more interesting, the domain is twisted time-dependently along the z- and y-axes.\r\n\r\n* [Video on YouTube](http://youtu.be/HJSkNlxiYH0).\r\n\r\n##### Basic use of transform feedback (tranform_feedback.cpp)\r\n\r\nExtracting iso-surfaces from a scalar field defined in terms shader code, and use transform feedback to capture geometry for wireframe rendering. This example is basically the same as cayley, the main difference is that instead of traversing the HistoPyramid twice when rendering wireframe, transform feedback is used to capture the geometry in the flat shading pass, and the result of this is rendered again using plain OpenGL to produce the line rendering.\r\n\r\nThe actual surface is an algebraic surface defined by 1 - 16xyz -4x^2 - 4y^2 - 4z^2 = iso. The application also provides the gradient field for this function, which is used instead of forward differences to determine surface normals.\r\n\r\n* [Video on YouTube](http://youtu.be/RlYYnsIS-Rs)\r\n\r\n##### Morphing algebraic shapes that emits particles (particles.cpp)\r\n\r\nThis example demonstrates using the surface generated by HPMC as input to a geometry shader that emits particles randomly over the surface. The particles are pulled by gravity, and uses the scalar field passed to HPMC to determine when particles hit the surface, and in this case, they bounce. To test if a particle hits the surface is done by evaluating the sign of the scalar field at the position of the particle at the beginning of the timestep and at the end. This approach is a bit too simple for these shapes, as they usually have a great deal of regions with multiple zeros, and this leads to the artefact of particles falling through the surface at some places.\r\n\r\nThe following render loop is used:\r\n* Use HPMC to determine the iso-surface of the current scalar field\r\n* Render the iso surface, but tap vertex position and normals into a transform feedback buffer.\r\n* Pass this buffer into a geometry shader that emits particles (points) at some of the triangles, output stored in another transform feedback buffer.\r\n* Pass the particles from the previous frame into a geometry shader that does a series of Euler-steps to integrate velocity and position, checking for collisions in-between. The output of this pass is concatenated at the end of the newly created particles using transform feedback.\r\n* Render the particles using a geometry shader that expands the point positions into quadrilateral screen-aligned billboards. \r\n\r\n* [Video on YouTube](http://youtu.be/S5NZxxDooCU)\r\n\r\n### Further references\r\n\r\nHistoPyramids are used and discussed in the following papers:\r\n\r\n> C. Dyken, M. Reimers, J. Seland,\r\n> [Semi-uniform Adaptive Patch Tessellation](http://heim.ifi.uio.no/~erikd/pdf/topofix_draft.pdf),\r\n> Computer Graphics Forum, to appear.\r\n \r\n> C. Dyken, M. Reimers, J. Seland,\r\n> [Real-Time GPU Silhouette Refinement using adaptively blended Bezier Patches](http://heim.ifi.uio.no/~erikd/pdf/silhouetteGPUdraft.pdf),\r\n> Computer Graphics Forum 27 (1), 2008, pp. 1-12.\r\n \r\n> I. Ihrke, G. Ziegler, A. Tevs, C. Theobalt, M. Magnor, H.-P. Seidel,\r\n> [Eikonal Rendering: Efficient Light Transport in Refractive Objects](http://www.mpi-inf.mpg.de/resources/EikonalRendering/index.html),\r\n> ACM Transactions on Graphics (Proc. ACM SIGGRAPH) 26 (3): 59-1 - 59-8, 2007\r\n \r\n> G. Ziegler, R. Dimitrov, C. Theobalt, H.-P. Seidel,\r\n> [Real-time Quadtree Analysis using HistoPyramids](https://domino.mpi-sb.mpg.de/intranet/ag4/ag4publ.nsf/ListPublications?OpenAgent&author=Gernot+AND+Ziegler),\r\n> Real-Time Image Processing 2007, San Jose, USA, 2007, 1-11\r\n \r\n> G. Ziegler, A. Tevs, C. Theobalt, H.-P. Seidel,\r\n> [On-the-fly Point Clouds through Histogram Pyramids](http://www.mpi-inf.mpg.de/~gziegler/gpu_pointlist/paper17_gpu_pointclouds.pdf),\r\n> 11th International Fall Workshop on Vision, Modeling and Visualization 2006 (VMV2006), Aachen, Germany, 2006, 137-144"}