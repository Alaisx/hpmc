/* -*- mode: C++; tab-width:4; c-basic-offset: 4; indent-tabs-mode:nil -*-
 ***********************************************************************
 *
 *  File: hpmc.h
 *
 *  Created: 24. June 2009
 *
 *  Version: $Id: $
 *
 *  Authors: Christopher Dyken <christopher.dyken@sintef.no>
 *
 *  This file is part of the HPMC library.
 *  Copyright (C) 2009 by SINTEF.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  ("GPL") version 2 as published by the Free Software Foundation.
 *  See the file LICENSE.GPL at the root directory of this source
 *  distribution for additional information about the GNU GPL.
 *
 *  For using HPMC with software that can not be combined with the
 *  GNU GPL, please contact SINTEF for aquiring a commercial license
 *  and support.
 *
 *  SINTEF, Pb 124 Blindern, N-0314 Oslo, Norway
 *  http://www.sintef.no
 *********************************************************************/

#include <cstdlib>
#include <cmath>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <string>
#include <hpmc.h>
#include <hpmc_internal.h>

using std::max;
using std::string;
using std::stringstream;

std::string
HPMCgenerateDefines( struct HPMCHistoPyramid* h )
{
    stringstream src;

    src << "// generated by HPMCgenerateDefines\n";
    src << "#define HP_SIZE_L2    " << h->m_base_size_l2 << "\n";
    src << "#define HP_COLS       " << h->m_base_cols << "\n";
    src << "#define HP_ROWS       " << h->m_base_rows << "\n";
    src << "#define HPMC_TILES            " << max( h->m_base_cols, h->m_base_rows) << "\n";
    src << "#define HPMC_TILES_F          float(HPMC_TILES)\n";
    src << "#define HPMC_BASE_COLS  " << (h->m_base_size/h->m_base_tile_width) << "\n";
    src << "#define HPMC_BASE_ROWS  " << (h->m_base_size/h->m_base_tile_height) << "\n";
    src << "#define FIELD_WIDTH   " << h->m_volume_width << "\n";
    src << "#define FIELD_HEIGHT  " << h->m_volume_height << "\n";
    src << "#define FIELD_DEPTH   " << h->m_volume_depth << "\n";
    src << "#define HPMC_FIELD_WIDTH_F    float(FIELD_WIDTH)\n";
    src << "#define HPMC_FIELD_HEIGHT_F   float(FIELD_HEIGHT)\n";
    src << "#define HPMC_FIELD_DEPTH_F    float(FIELD_DEPTH)\n";
    src << "#define HPMC_TILE_WIDTH       " << h->m_base_tile_width << "\n";
    src << "#define HPMC_TILE_HEIGHT      " << h->m_base_tile_height << "\n";
    src << "#define HPMC_HP_TILE_WIDTH_F  float(HPMC_TILE_WIDTH)\n";
    src << "#define HPMC_HP_TILE_HEIGHT_F float(HPMC_TILE_HEIGHT)\n";

    return src.str();
}

std::string
HPMCgenerateBaselevelShader( struct HPMCHistoPyramid* h )
{
    stringstream src;

    src << "// generated by HPMCgenerateBaselevelShader\n";
    src << "uniform sampler1D  vertexcount;\n";
    src << "uniform float      threshold;\n";
    src << "void\n";
    src << "main()\n";
    src << "{\n";
    src << "    vec2 stp = vec2( HPMC_BASE_COLS, HPMC_BASE_ROWS ) * gl_TexCoord[0].xy;\n";
    src << "    float slice = dot( vec2( 1.0, float(HPMC_BASE_COLS)), floor( stp ) );\n";
    if( h->m_func_omit_boundary ) {
       src << "    if(slice < HPMC_FIELD_DEPTH_F-1.0 ) {\n";
    }
    else {
       src << "    if(slice < HPMC_FIELD_DEPTH_F-0.0 ) {\n";
    }
    src << "        const vec3 delta = vec3( 1.0/HPMC_FIELD_WIDTH_F,\n";
    src << "                                 1.0/HPMC_FIELD_HEIGHT_F,\n";
    src << "                                 1.0 );\n";
    src << "        vec3 tp = vec3( fract( stp ), slice );\n";
    if( h->m_func_omit_boundary ) {
        src << "        vec4 mask = vec4( (tp.x < (HPMC_FIELD_WIDTH_F-1)/HPMC_FIELD_WIDTH_F) && (tp.y < (HPMC_FIELD_HEIGHT_F-1)/HPMC_FIELD_HEIGHT_F),\n";
        src << "                          (tp.x < (HPMC_FIELD_WIDTH_F-2)/HPMC_FIELD_WIDTH_F) && (tp.y < (HPMC_FIELD_HEIGHT_F-1)/HPMC_FIELD_HEIGHT_F),\n";
        src << "                          (tp.x < (HPMC_FIELD_WIDTH_F-1)/HPMC_FIELD_WIDTH_F) && (tp.y < (HPMC_FIELD_HEIGHT_F-2)/HPMC_FIELD_HEIGHT_F),\n";
        src << "                          (tp.x < (HPMC_FIELD_WIDTH_F-2)/HPMC_FIELD_WIDTH_F) && (tp.y < (HPMC_FIELD_HEIGHT_F-2)/HPMC_FIELD_HEIGHT_F) );\n";
    }
    else {
        src << "        vec4 mask = vec4( (tp.x < (HPMC_FIELD_WIDTH_F-0)/HPMC_FIELD_WIDTH_F) && (tp.y < (HPMC_FIELD_HEIGHT_F-0)/HPMC_FIELD_HEIGHT_F),\n";
        src << "                          (tp.x < (HPMC_FIELD_WIDTH_F-1)/HPMC_FIELD_WIDTH_F) && (tp.y < (HPMC_FIELD_HEIGHT_F-0)/HPMC_FIELD_HEIGHT_F),\n";
        src << "                          (tp.x < (HPMC_FIELD_WIDTH_F-0)/HPMC_FIELD_WIDTH_F) && (tp.y < (HPMC_FIELD_HEIGHT_F-1)/HPMC_FIELD_HEIGHT_F),\n";
        src << "                          (tp.x < (HPMC_FIELD_WIDTH_F-1)/HPMC_FIELD_WIDTH_F) && (tp.y < (HPMC_FIELD_HEIGHT_F-1)/HPMC_FIELD_HEIGHT_F) );\n";
    }
    // fetch 3x3x2 neighbourhood from scalar field and build partial MC codes
    for(int c=0; c<3; c++) {
        src << "        vec3 l"
            << c 
            << " = vec3( \n";
        for(int i=0; i<6; i++) {
            src << "            (HPMC_sample( tp + delta*vec3( "
                << ((i>>1)-0.5) << ", "
                << (c-0.5) << ", "
                << (float)(i&1) << ") ) < threshold ? "
                << ((i&1)==0?" 1.0":"16.0") << " : 0.0 )" 
                << ((i&1)==0?" +\n":(i<5?",\n":"\n"));
        }
        src << "        );\n";
    }

    // build codes for 2x2x1 set of voxels, scaled to fractionals
    src << "        vec4 codes = (1.0/256.0)*vec4(\n";
    src << "            l0.x+2.0*l0.y+4.0*l1.x +8.0*l1.y+0.5,\n";
    src << "            l0.y+2.0*l0.z+4.0*l1.y +8.0*l1.z+0.5,\n";
    src << "            l1.x+2.0*l1.y+4.0*l2.x +8.0*l2.y+0.5,\n";
    src << "            l1.y+2.0*l1.z+4.0*l2.y +8.0*l2.z+0.5\n";
    src << "        );\n";

    // fetch the triangle count for the codes of the 2x2x1 set of voxels
    src << "        vec4 counts = vec4(\n";
    src << "            texture1D( vertexcount, codes.x ).a,\n";
    src << "            texture1D( vertexcount, codes.y ).a,\n";
    src << "            texture1D( vertexcount, codes.z ).a,\n";
    src << "            texture1D( vertexcount, codes.w ).a\n";
    src << "        );\n";

    // encode the vertex count in the integer part and the code in the fractional part.
    src << "        gl_FragColor = mask*(counts + codes);\n";
    src << "    } \n";
    src << "    else {\n";
    src << "        gl_FragColor = vec4(0.0, 0.0, 0.4, 0.0);\n";
    src << "    }\n";
    src << "}\n";

    return src.str();
}

std::string
HPMCgenerateReductionShader( struct HPMCHistoPyramid* h, const std::string& filter  )
{
    stringstream src;

    src << "// generated by HPMCgenerateReductionShader with filter=\""<<filter<<"\"\n";
    src << "uniform sampler2D  histopyramid;\n";
    src << "uniform vec2       delta;\n";
    src << "void\n";
    src << "main()\n";
    src << "{\n";
    src << "    vec4 sums = vec4(\n";
    for(int i=0; i<4; i++) {
        src << "        dot( vec4(1.0), "
            << filter
            << "( texture2D( histopyramid, gl_TexCoord[0].xy+delta."
            << ((i&1)==0?'x':'y')
            << ((i&2)==0?'x':'y')
            << " ) ) )"
            << (i<3?",\n":"\n");
    }
    src << "    );\n";
    src << "    gl_FragColor = sums;\n";
    src << "}\n";

    return src.str();
}

std::string
HPMCgenerateGPGPUVertexPassThroughShader( struct HPMCHistoPyramid* h )
{
    stringstream src;

    src << "// generated by HPMCgenerateGPGPUVertexPassThroughShader\n";
    src << "void\n";
    src << "main()\n";
    src << "{\n";
    src << "    gl_TexCoord[0] = 0.5*gl_Vertex+vec4(0.5);\n";
    src << "    gl_Position    = gl_Vertex;\n";
    src << "    gl_FrontColor  = gl_Color;\n";
    src << "}\n";
    return src.str();
}

std::string
HPMCgenerateScalarFieldFetch( struct HPMCHistoPyramid* h )
{
    stringstream src;

    src << "// generated by HPMCgenerateScalarFieldFetch" << std::endl;
    switch( h->m_volume_layout ) {
    case HPMC_VOLUME_LAYOUT_FUNCTION:
        src << "float" << std::endl;
        src << "HPMC_sample( vec3 p )"<< std::endl;
        src << "{" << std::endl;
        src << "    p.z = (p.z+0.5)*(1.0/float(HPMC_FIELD_DEPTH_F));" << std::endl;
        src << "    return dot(p,p)-1.0;" << std::endl;
        src << "}" << std::endl;
        src << "vec4" << std::endl;
        src << "HPMC_sampleGrad( vec3 p )" << std::endl;
        src << "{" << std::endl;
        src << "    p.z = (p.z+0.5)*(1.0/float(HPMC_FIELD_DEPTH_F));" << std::endl;
        src << "    return vec4( 2.0*p, dot(p,p)-1.0);" << std::endl;
        src << "}" << std::endl;
        break;

    case HPMC_VOLUME_LAYOUT_TEXTURE_3D:
        src << "uniform sampler3D  HPMC_scalarfield;" << std::endl;
        src << "float" << std::endl;
        src << "HPMC_sample( vec3 p )" << std::endl;
        src << "{" << std::endl;
        src << "    p.z = (p.z+0.5)*(1.0/float(HPMC_FIELD_DEPTH_F+1));" << std::endl;
        src << "    return texture3D( HPMC_scalarfield, p ).a;" << std::endl;
        src << "}" << std::endl;
        break;
    case HPMC_VOLUME_LAYOUT_TEXTURE_3D_PACKED:
        src << "uniform sampler3D  HPMC_scalarfield;" << std::endl;
        src << "float" << std::endl;
        src << "HPMC_sample( vec3 p )" << std::endl;
        src << "{" << std::endl;
        src << "    float z = floor(p.z)/4.0;"<<std::endl;
        src << "    float n = fract( z ); " << std::endl;
        src << "    p.z = (4.0/float(HPMC_FIELD_DEPTH_F)) * ( floor(z)+0.5);" << std::endl;
//        src << "    return texture3D( HPMC_scalarfield, p ).a;" << std::endl;
        src << "    return dot( texture3D( HPMC_scalarfield, p )," << std::endl;
        src << "                vec4( equal( vec4(n), vec4(0.0/4.0, 1.0/4.0, 2.0/4.0, 3.0/4.0) ) ) );"<<std::endl;
        src << "}" << std::endl;

        break;
    }
    return src.str();
}

std::string
HPMCgenerateExtractVertexFunction( struct HPMCHistoPyramid* h )
{
    stringstream src;

    src << "// generated by HPMCgenerateExtractShaderFunctions\n";
    src << "uniform sampler2D  HPMC_histopyramid;\n";
    src << "uniform sampler2D  HPMC_edge_table;\n";
    src << "uniform float      HPMC_key_offset;\n";
    src << "uniform float      HPMC_threshold;\n";
    src << "void\n";
    src << "extractVertex( out vec3 p, out vec3 n )\n";
    src << "{\n";
    src << "    float key_ix = gl_Vertex.x + HPMC_key_offset;\n";
    src << "    vec2 texpos = vec2(0.5);\n";
    src << "    vec4 delta_x = vec4( -0.5,  0.5, -0.5, 0.25 );\n";
    src << "    vec4 delta_y = vec4(  0.0, -0.5,  0.0, 0.25 );\n";
    src << "    vec4 sums,hist,mask;\n";
    // upper layer traversal
    src << "    for(int i=HP_SIZE_L2; i>0; i--) {\n";
    src << "        vec4 sums = texture2DLod( HPMC_histopyramid, texpos, float(i) );\n";
    src << "        vec4 hist = sums;\n";
    src << "        hist.w   += hist.z;\n";
    src << "        hist.zw  += hist.yy;\n";
    src << "        hist.yzw += hist.xxx;\n";
    src << "        vec4 mask = vec4( lessThan( vec4(key_ix), hist ) );\n";
    src << "        texpos   += vec2( dot( mask, delta_x ), dot( mask, delta_y ) );\n";
    src << "        key_ix   -= dot( sums.xyz, vec3(1.0)-mask.xyz );\n";
    src << "        delta_x  *= 0.5;\n";
    src << "        delta_y  *= 0.5;\n";
    src << "    }\n";
    // bottom layer traversal
    src << "    vec4 raw  = texture2DLod( HPMC_histopyramid, texpos, 0.0 );\n";
    src << "    sums = floor(raw);\n";
    src << "    hist = sums;\n";
    src << "    hist.w   += hist.z;\n";
    src << "    hist.zw  += hist.yy;\n";
    src << "    hist.yzw += hist.xxx;\n";
    src << "    mask = vec4( lessThan( vec4(key_ix), hist ) );\n";
    src << "    float nib = dot(vec4(mask), vec4(-1.0,-1.0,-1.0, 3.0));\n";
    src << "    texpos   += vec2( dot( mask, delta_x ), dot( mask, delta_y ) );\n";
    src << "    key_ix   -= dot( sums.xyz, vec3(1.0)-mask.xyz );\n";
    src << "    float val = fract( dot( raw, vec4(equal(vec4(nib),vec4(0,1,2,3))) ) );\n";
    src << "    vec2 foo = vec2(HP_COLS,HP_ROWS)*texpos;\n";
    src << "    vec2 tp = fract(foo);\n";
    src << "    float slice = dot( vec2(1.0,HP_COLS), floor(foo));\n";

    // we know which voxel, determine where the intersection is
    src << "    vec4 edge = texture2D( HPMC_edge_table, vec2((1.0/16.0)*(key_ix+0.5), val ) );\n";
    src << "    vec3 shift = edge.xyz;\n";
    src << "    vec3 axis = vec3( equal(vec3(0.0, 1.0, 2.0), vec3(edge.w)) );\n";
    src << "    vec3 pa = vec3(tp, slice)\n";
    src << "            + vec3(1.0/HPMC_FIELD_WIDTH_F, 1.0/HPMC_FIELD_HEIGHT_F, 1.0)*shift;\n";
    src << "    vec3 pb = pa\n";
    src << "            + vec3(1.0/HPMC_FIELD_WIDTH_F, 1.0/HPMC_FIELD_HEIGHT_F, 1.0)*axis;\n";
    if( 1 || h->m_func_discrete_gradient ) {
        src << "    float va = HPMC_sample( pa );\n";
        src << "    vec3 na = vec3( HPMC_sample( pa + vec3( 1.0/HPMC_FIELD_WIDTH_F, 0.0, 0.0 ) ),\n";
        src << "                    HPMC_sample( pa + vec3( 0.0, 1.0/HPMC_FIELD_HEIGHT_F, 0.0 ) ),\n";
        src << "                    HPMC_sample( pa + vec3( 0.0, 0.0, 1.0 ) ) );\n";
        src << "    vec3 nb = vec3( HPMC_sample( pb + vec3( 1.0/HPMC_FIELD_WIDTH_F, 0.0, 0.0 ) ),\n";
        src << "                    HPMC_sample( pb + vec3( 0.0, 1.0/HPMC_FIELD_HEIGHT_F, 0.0 ) ),\n";
        src << "                    HPMC_sample( pb + vec3( 0.0, 0.0, 1.0 ) ) );\n";
        src << "    float t = (va-HPMC_threshold)/(va-dot(na,axis));\n";
    }
    else {
        src << "    vec4 fa = HPMC_sampleGrad( pa );\n";
        src << "    vec3 na = fa.xyz;\n";
        src << "    float va = fa.w;\n";
        src << "    vec4 fb = HPMC_sampleGrad( pb );\n";
        src << "    vec3 nb = fb.xyz;\n";
        src << "    float vb = fb.w;\n";
        src << "    float t = (va-HPMC_threshold)/(va-vb);\n";
    }
    src << "    p = mix(pa, pb, t );\n";
    src << "    p.z *= (1.0/HPMC_FIELD_DEPTH_F);" << std::endl;

    // map texel center grid to [0,1]^3
    src << "    p.xy -= vec2(0.5/HPMC_FIELD_WIDTH_F, 0.5/HPMC_FIELD_HEIGHT_F );\n";
    src << "    p.xy *= vec2(HPMC_FIELD_WIDTH_F/(HPMC_FIELD_WIDTH_F-1), HPMC_FIELD_HEIGHT_F/(HPMC_FIELD_HEIGHT_F-1) );\n";
    src << "    n = vec3(HPMC_threshold)-mix(na, nb,t);\n";

    src << "}\n";

    return src.str();
}
